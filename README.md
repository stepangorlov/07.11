python
Временная сложность Python:
O(N! × N)
Разбор сложности:
Количество рекурсивных вызовов: O(N!)
Строка 0: N вариантов
Строка 1: ~N-1 вариантов (исключая конфликтные)
Строка 2: ~N-2 вариантов
Строка N-1: 1 вариант
Итого: N × (N-1) × (N-2) × ... × 1 = N!
Стоимость is_safe(): O(N)
В худшем случае проверяем все предыдущие строки (0 до row-1)
Каждая проверка: 2 сравнения (вертикаль + диагональ)
Общая сложность: O(N! × N)
Почему именно O(N! × N)?
Алгоритм перебирает ~N! различных расстановок
Для каждой расстановки выполняет O(N) операций проверки
Умножаем: N! × N

Java
Временная сложность Java:
O(N! × N)
Разбор сложности:
Рекурсивное дерево: O(N!) узлов
Каждый узел представляет частичное решение
Глубина дерева: N уровней
Ширина уменьшается на каждом уровне
Операции на узле: O(N)
isSafe(): цикл от 0 до row-1 → O(N)
Присваивание и backtrack: O(1)
Память для решений: O(N! × N)
Каждое решение занимает O(N) памяти
Всего O(N!) решений
Особенности Java:
queens.clone() создает копию массива для каждого решения
Использование массивов вместо списков для эффективности
Приватные методы для инкапсуляции

CPP
Временная сложность C++:
O(N! × N)
Разбор сложности:
Количество состояний: O(N!)
Вектор решений растет факториально
Каждое состояние - частичная расстановка
Операции на состояние: O(N)
isSafe(): O(N) сравнений
Изменение вектора: O(1) амортизированно
Общая сложность: O(N! × N)
Особенности C++:
Передача по ссылке & избегает копирования
const vector& гарантирует неизменяемость в isSafe()
Векторы обеспечивают эффективное управление памятью

## контрольный вопрос:Какова временная сложность задачи о N ферзях?
1. Откуда берется N!
Алгоритм перебирает расстановки ферзей построчно:
Строка 0: N возможных позиций для первого ферзя
Строка 1: ~N-1 позиций (исключая конфликтные столбцы и диагонали)
Строка 2: ~N-2 позиций
Строка N-1: 1 позиция
Математически: N × (N-1) × (N-2) × ... × 1 = N!
2. Откуда берется множитель N
На каждой позиции выполняется проверка безопасности isSafe(), которая:
Проверяет все предыдущие строки (от 0 до row-1)
Выполняет 2 проверки для каждой строки: вертикаль и диагонали
В худшем случае: O(N) операций на каждую проверяемую позицию
3. Итоговая формула
Общая сложность = Количество_позиций × Стоимость_проверки = N! × N
Пример для N=8:
8! = 40,320 возможных расстановок
На каждую расстановку ~8 проверок
Итого: 40,320 × 8 ≈ 322,560 операций
Почему именно такая сложность?
Не O(N^N): Алгоритм не перебирает все N^N вариантов, а использует оптимизации
Не O(2^N): Сложность растет быстрее экспоненциальной
Факториальная сложность характерна для комбинаторных задач полного перебора





