def solve_n_queens(n=8):
    """
    Решение задачи о расстановке N ферзей на шахматной доске N×N
    так, чтобы ни один ферзь не атаковал другого
    
    Args:
        n (int): размер доски (по умолчанию 8)
    
    Returns:
        list: список всех возможных решений
    """
    
    def is_safe(queens, row, col):
        """
        Проверка безопасности расстановки ферзя на позицию (row, col)
        
        Args:
            queens: список текущих позиций ферзей (индекс = строка, значение = столбец)
            row: текущая строка для проверки
            col: текущий столбец для проверки
        
        Returns:
            bool: True если позиция безопасна, False если под атакой
        """
        # Проверяем все предыдущие строки (от 0 до row-1)
        for i in range(row):
            # Проверка 1: По вертикали (одинаковые столбцы)
            # Если в строке i ферзь уже стоит в столбце col - конфликт
            if queens[i] == col:
                return False
            
            # Проверка 2: По диагоналям
            # Если разность координат по строкам и столбцам одинакова - конфликт
            # Это означает, что ферзи находятся на одной диагонали
            if abs(queens[i] - col) == abs(i - row):
                return False
        
        return True

    def backtrack(row, queens, solutions):
        """
        Рекурсивная функция backtracking для поиска всех решений
        
        Args:
            row: текущая строка для размещения ферзя
            queens: текущая расстановка ферзей
            solutions: список для сохранения найденных решений
        """
        # Базовый случай: все ферзи успешно расставлены
        if row == n:
            # Сохраняем копию текущего решения
            solutions.append(queens[:])
            return
        
        # Рекурсивный случай: пробуем разместить ферзя в каждом столбце текущей строки
        for col in range(n):
            # Проверяем, безопасно ли разместить ферзя в этой позиции
            if is_safe(queens, row, col):
                # Делаем ход - размещаем ферзя в строке row, столбце col
                queens[row] = col
                
                # Рекурсивно размещаем ферзя в следующей строке
                backtrack(row + 1, queens, solutions)
                
                # Backtrack: отменяем выбор (возвращаем -1)
                # Это не обязательно для работы алгоритма, но делает логику явной
                queens[row] = -1

    # Инициализация
    # Создаем список для хранения позиций ферзей
    # queens[i] = j означает, что в строке i ферзь находится в столбце j
    # -1 означает, что ферзь еще не размещен в этой строке
    queens = [-1] * n
    solutions = []  # Список для хранения всех найденных решений
    
    # Запуск алгоритма с первой строки (row = 0)
    backtrack(0, queens, solutions)
    
    return solutions

def print_solution(queens):
    """
    Визуализация решения в виде шахматной доски
    
    Args:
        queens: список позиций ферзей
    """
    n = len(queens)
    print("+" + "---+" * n)
    for i in range(n):
        row = "|"
        for j in range(n):
            if queens[i] == j:
                row += " Q |"
            else:
                row += "   |"
        print(row)
        print("+" + "---+" * n)
    print()

# Основная программа
if __name__ == "__main__":
    # Решение для стандартной шахматной доски 8×8
    solutions = solve_n_queens(8)
    
    # Вывод результатов
    print(f"Всего найдено решений для доски 8×8: {len(solutions)}")
    print("Первые 3 решения:")
    
    for i, solution in enumerate(solutions[:3]):
        print(f"Решение #{i + 1}:")
        print_solution(solution)
